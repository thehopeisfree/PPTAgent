<!DOCTYPE html>
<html lang="en">
<head>
<meta charset="utf-8" />
<title>PPTAgent Rollout Viewer</title>
<style>
/* ── Global reset ── */
* { margin: 0; padding: 0; box-sizing: border-box; }
body { font-family: -apple-system, BlinkMacSystemFont, 'Segoe UI', Roboto, sans-serif; background: #f5f5f5; color: #1e1e2e; }

#file-input { display: none; }
@keyframes spin { to { transform: rotate(360deg); } }

/* ── Layout ── */
#layout { display: flex; height: 100vh; }

/* ── Sidebar ── */
#sidebar {
  width: 240px;
  min-width: 240px;
  background: #f8f9fb;
  border-right: 1px solid #e2e8f0;
  display: flex;
  flex-direction: column;
  overflow: hidden;
}
#sidebar-header {
  padding: 12px 16px;
  display: flex;
  align-items: center;
  justify-content: space-between;
  border-bottom: 1px solid #e2e8f0;
}
#sidebar-header span { font-size: 16px; font-weight: 700; color: #7c3aed; }
#btn-add {
  width: 28px;
  height: 28px;
  border-radius: 6px;
  border: 1px solid #e2e8f0;
  background: #fff;
  color: #7c3aed;
  font-size: 20px;
  cursor: pointer;
  display: flex;
  align-items: center;
  justify-content: center;
  line-height: 1;
}
#btn-add:hover { background: #f1f5f9; }

#sidebar-drop {
  margin: 8px 12px;
  padding: 16px 8px;
  border: 2px dashed #cbd5e1;
  border-radius: 8px;
  text-align: center;
  font-size: 13px;
  color: #94a3b8;
  cursor: pointer;
  transition: border-color 0.2s, background 0.2s;
}
#sidebar-drop:hover, #sidebar-drop.dragover {
  border-color: #7c3aed;
  background: rgba(124,58,237,0.04);
}

#rollout-list {
  flex: 1;
  overflow-y: auto;
  padding: 4px 8px;
}
.rollout-card {
  padding: 8px 10px;
  margin-bottom: 4px;
  border-radius: 6px;
  border: 1.5px solid transparent;
  cursor: pointer;
  transition: background 0.15s, border-color 0.15s;
  position: relative;
}
.rollout-card:hover { background: #eef2ff; }
.rollout-card.active { border-color: #7c3aed; background: #f5f3ff; }
.rollout-card-name {
  font-size: 13px;
  font-weight: 600;
  color: #1e293b;
  overflow: hidden;
  text-overflow: ellipsis;
  white-space: nowrap;
  padding-right: 20px;
}
.rollout-card-info {
  font-size: 12px;
  color: #64748b;
  margin-top: 2px;
  line-height: 1.5;
}
.rollout-card-delete {
  position: absolute;
  top: 6px;
  right: 6px;
  width: 20px;
  height: 20px;
  border: none;
  background: transparent;
  color: #94a3b8;
  font-size: 15px;
  cursor: pointer;
  border-radius: 4px;
  display: flex;
  align-items: center;
  justify-content: center;
  line-height: 1;
}
.rollout-card-delete:hover { background: #fee2e2; color: #dc2626; }
.rollout-card-loading { opacity: 0.5; pointer-events: none; }
.rollout-card-loading .rollout-card-info::after {
  content: '';
  display: inline-block;
  width: 12px;
  height: 12px;
  border: 2px solid #e2e8f0;
  border-top: 2px solid #7c3aed;
  border-radius: 50%;
  animation: spin 0.8s linear infinite;
  margin-left: 4px;
  vertical-align: middle;
}

.rollout-card-toggle {
  display: flex;
  align-items: center;
  gap: 4px;
  font-size: 12px;
  color: #7c3aed;
  cursor: pointer;
  margin-top: 4px;
}
.rollout-card-toggle input { margin: 0; cursor: pointer; }
.rollout-card-groups {
  margin-top: 4px;
  padding: 4px 0 0;
  border-top: 1px dashed #e2e8f0;
  font-size: 11px;
  color: #475569;
  line-height: 1.7;
}
.group-iter { color: #94a3b8; font-size: 11px; }
.group-set {
  display: inline;
  background: #fef3c7;
  color: #92400e;
  padding: 1px 4px;
  border-radius: 3px;
  font-size: 11px;
  margin: 0 2px;
}

/* ── Viewer area ── */
#viewer-area { flex: 1; display: flex; flex-direction: column; overflow: hidden; position: relative; }

#empty-state {
  flex: 1;
  display: flex;
  flex-direction: column;
  align-items: center;
  justify-content: center;
  gap: 16px;
  color: #94a3b8;
  cursor: pointer;
}
#empty-state .icon { font-size: 56px; }
#empty-state .label { font-size: 18px; color: #475569; }
#empty-state .sublabel { font-size: 14px; }
#empty-state.dragover { background: rgba(124,58,237,0.04); }

/* ── Conflict bar ── */
#conflict-bar {
  background: #fff;
  border-top: 1px solid #e2e8f0;
  padding: 8px 16px;
  display: none;
  gap: 12px;
  overflow: auto;
  flex-shrink: 0;
  max-height: 160px;
}
#conflict-bar.visible { display: flex; }
.cb-group {
  flex-shrink: 0;
  border-left: 3px solid #f59e0b;
  padding: 6px 12px;
  background: #fffbeb;
  border-radius: 0 6px 6px 0;
  cursor: pointer;
  transition: background 0.15s;
  min-width: 180px;
}
.cb-group:hover { background: #fef3c7; }
.cb-group.active { background: #fde68a; border-left-color: #d97706; }
.cb-group-header {
  font-size: 12px;
  font-weight: 700;
  color: #92400e;
  margin-bottom: 4px;
}
.cb-edge {
  font-size: 11px;
  color: #475569;
  font-family: 'Cascadia Code', 'Fira Code', monospace;
  line-height: 1.6;
}
.cb-env {
  font-size: 10px;
  color: #64748b;
  font-family: 'Cascadia Code', 'Fira Code', monospace;
  margin-top: 2px;
}
.group-highlight-rect {
  fill: rgba(245, 158, 11, 0.35);
  stroke: #f59e0b;
  stroke-width: 4;
  pointer-events: none;
  animation: eid-pulse 1s ease-in-out infinite alternate;
}
@keyframes eid-pulse {
  from { fill: rgba(245, 158, 11, 0.25); }
  to   { fill: rgba(245, 158, 11, 0.45); }
}

/* ── Viewer styles ── */
#app { display: none; flex-direction: column; flex: 1; min-height: 0; overflow: hidden; }

#toolbar {
  background: #ffffff;
  border-bottom: 1px solid #e2e8f0;
  padding: 8px 16px;
  display: flex;
  align-items: center;
  gap: 16px;
  flex-wrap: wrap;
}
#toolbar h1 { font-size: 16px; color: #7c3aed; white-space: nowrap; }
#tabs { display: flex; gap: 4px; flex-wrap: wrap; }
.tab {
  background: #f1f5f9;
  border: 1px solid #e2e8f0;
  color: #334155;
  padding: 4px 12px;
  border-radius: 6px;
  cursor: pointer;
  font-size: 13px;
  display: flex;
  align-items: center;
  gap: 6px;
}
.tab:hover { background: #e2e8f0; }
.tab.active { background: #7c3aed; border-color: #7c3aed; color: #fff; }
.tab-badge {
  font-size: 10px;
  background: #e2e8f0;
  color: #475569;
  padding: 1px 5px;
  border-radius: 3px;
}
.tab.active .tab-badge { background: rgba(255,255,255,0.25); color: #fff; }

#toggles {
  display: flex;
  gap: 10px;
  flex-wrap: wrap;
  margin-left: auto;
  font-size: 12px;
  color: #475569;
}
#toggles label { display: flex; align-items: center; gap: 4px; cursor: pointer; white-space: nowrap; }
.swatch {
  display: inline-block;
  width: 14px;
  height: 14px;
  border-radius: 2px;
  vertical-align: middle;
}

#main {
  display: flex;
  flex: 1;
  overflow: hidden;
  min-height: 0;
}

#slide-area {
  flex: 1;
  overflow: auto;
  padding: 24px;
  display: flex;
  justify-content: center;
  align-items: flex-start;
  position: relative;
  background: #e8ecf1;
}

#slide-container {
  position: relative;
  flex-shrink: 0;
  box-shadow: 0 2px 16px rgba(0,0,0,0.12);
  border-radius: 4px;
  overflow: visible;
  background: #fff;
}

.iter-slide { position: absolute; top: 0; left: 0; width: 100%; height: 100%; }
.slide-base { position: absolute; top: 0; left: 0; width: 100%; height: 100%; }
.slide-base > div { position: relative; }
.overlay-svg {
  position: absolute;
  top: 0;
  left: 0;
  pointer-events: none;
  z-index: 10000;
}
.overlay-svg rect, .overlay-svg line, .overlay-svg circle, .overlay-svg text, .overlay-svg path, .overlay-svg polygon { pointer-events: all; }

#tooltip {
  display: none;
  position: fixed;
  background: #ffffff;
  border: 1px solid #e2e8f0;
  border-radius: 6px;
  padding: 8px 12px;
  font-size: 12px;
  max-width: 280px;
  z-index: 99999;
  line-height: 1.5;
  box-shadow: 0 4px 12px rgba(0,0,0,0.1);
  color: #1e293b;
}
#tooltip hr { border: none; border-top: 1px solid #e2e8f0; margin: 4px 0; }
.tip-defect { color: #dc2626; font-weight: 600; }

#panel {
  width: 360px;
  background: #ffffff;
  border-left: 1px solid #e2e8f0;
  display: flex;
  flex-direction: column;
  transition: width 0.2s;
  overflow: hidden;
}
#panel.collapsed { width: 0; min-width: 0; border-left: none; }
#panel-header {
  padding: 8px;
  border-bottom: 1px solid #e2e8f0;
  display: flex;
  align-items: center;
  gap: 4px;
}
#panel-tabs { display: flex; gap: 2px; flex: 1; }
.panel-tab {
  background: #f1f5f9;
  border: 1px solid #e2e8f0;
  color: #334155;
  padding: 3px 8px;
  border-radius: 4px;
  cursor: pointer;
  font-size: 11px;
}
.panel-tab:hover { background: #e2e8f0; }
.panel-tab.active { background: #7c3aed; border-color: #7c3aed; color: #fff; }
#panel-header > button {
  background: #f1f5f9;
  border: 1px solid #e2e8f0;
  color: #475569;
  padding: 3px 8px;
  border-radius: 4px;
  cursor: pointer;
  font-size: 12px;
}
#panel-header > button:hover { background: #e2e8f0; }
#panel-content {
  flex: 1;
  overflow: auto;
  padding: 12px;
  font-size: 11px;
  font-family: 'Cascadia Code', 'Fira Code', monospace;
  line-height: 1.4;
  white-space: pre-wrap;
  word-break: break-all;
  color: #475569;
}

/* ── Timeline ── */
#timeline {
  background: #ffffff;
  border-bottom: 1px solid #e2e8f0;
  padding: 6px 16px;
  display: flex;
  align-items: center;
  gap: 12px;
}
#timeline-controls { display: flex; gap: 4px; align-items: center; flex-shrink: 0; }
#timeline-controls button {
  background: #f1f5f9;
  border: 1px solid #e2e8f0;
  color: #475569;
  width: 28px;
  height: 28px;
  border-radius: 4px;
  cursor: pointer;
  font-size: 14px;
  display: flex;
  align-items: center;
  justify-content: center;
}
#timeline-controls button:hover { background: #e2e8f0; }
#speed-select {
  background: #f1f5f9;
  border: 1px solid #e2e8f0;
  color: #475569;
  padding: 2px 4px;
  border-radius: 4px;
  font-size: 11px;
}
#timeline-track {
  flex: 1;
  display: flex;
  align-items: center;
  gap: 12px;
  position: relative;
  min-height: 28px;
  overflow-x: auto;
}
#timeline-progress {
  position: absolute;
  left: 0;
  top: 50%;
  height: 3px;
  background: #7c3aed;
  border-radius: 2px;
  transition: width 0.3s ease;
  width: 0;
  z-index: 0;
}
.timeline-marker {
  display: flex;
  align-items: center;
  gap: 4px;
  cursor: pointer;
  font-size: 11px;
  color: #94a3b8;
  position: relative;
  z-index: 1;
  padding: 2px 6px;
  border-radius: 4px;
  transition: background 0.15s;
  white-space: nowrap;
}
.timeline-marker:hover { background: #f1f5f9; }
.timeline-marker.active { color: #7c3aed; font-weight: 600; }
.marker-dot {
  width: 10px;
  height: 10px;
  border-radius: 50%;
  background: #cbd5e1;
  flex-shrink: 0;
}
.timeline-marker.active .marker-dot { background: #7c3aed; }
.marker-badge {
  font-size: 9px;
  background: #f1f5f9;
  color: #475569;
  padding: 0 4px;
  border-radius: 3px;
}
.timeline-marker.taboo .marker-dot { background: #ef4444; }
.timeline-marker.taboo .marker-label { text-decoration: line-through; color: #ef4444; }

/* ── Animation layer ── */
#anim-layer {
  position: absolute;
  top: 0;
  left: 0;
  width: 100%;
  height: 100%;
  z-index: 9999;
  pointer-events: none;
  display: none;
}
.anim-rect { position: absolute; }

/* Hover-to-highlight: defect labels */
.defect-group { opacity: 0.25; transition: opacity 0.15s ease; }
.defect-group.active, .defect-group:hover { opacity: 1; }

/* Ensure all SVG children are hoverable */
.defect-group * { pointer-events: all; }

/* Animated marching-ants trace for movement arrows */
@keyframes marchingAnts { to { stroke-dashoffset: -16; } }
.move-trace { stroke-dasharray: 10 6; animation: marchingAnts 0.5s linear infinite; }
</style>
</head>
<body>

<!-- ── Layout ── -->
<div id="layout">
  <div id="sidebar">
    <div id="sidebar-header">
      <span>Rollouts</span>
      <button id="btn-add" title="Add rollout (+)">+</button>
    </div>
    <div id="sidebar-drop">Drop .tar.gz here<br>or click +</div>
    <div id="rollout-list"></div>
  </div>
  <div id="viewer-area">
    <div id="empty-state">
      <div class="icon">&#x1F4E6;</div>
      <div class="label">Drop a .tar.gz or click + to load a rollout</div>
      <div class="sublabel">Self-contained rollout viewer &mdash; no server needed</div>
    </div>
    <div id="app"></div>
  </div>
</div>
<input type="file" id="file-input" accept=".tar.gz,.tgz" multiple />

<script>
// ═══════════════════════════════════════════════════════════════
// Tar.gz parsing
// ═══════════════════════════════════════════════════════════════

async function decompressGzip(buffer) {
  if (typeof DecompressionStream === 'undefined') {
    throw new Error('DecompressionStream API not supported. Use Chrome 80+, Firefox 113+, or Safari 16.4+.');
  }
  var ds = new DecompressionStream('gzip');
  var blob = new Blob([buffer]);
  var stream = blob.stream().pipeThrough(ds);
  var reader = stream.getReader();
  var chunks = [];
  var totalLen = 0;
  while (true) {
    var result = await reader.read();
    if (result.done) break;
    chunks.push(result.value);
    totalLen += result.value.length;
  }
  var out = new Uint8Array(totalLen);
  var offset = 0;
  for (var i = 0; i < chunks.length; i++) {
    out.set(chunks[i], offset);
    offset += chunks[i].length;
  }
  return out;
}

function parseTar(tarBytes) {
  var files = new Map();
  var offset = 0;
  var decoder = new TextDecoder();
  while (offset + 512 <= tarBytes.length) {
    var header = tarBytes.slice(offset, offset + 512);
    // Check for empty block (end of archive)
    var allZero = true;
    for (var i = 0; i < 512; i++) {
      if (header[i] !== 0) { allZero = false; break; }
    }
    if (allZero) break;

    // Parse filename (bytes 0-99)
    var nameRaw = decoder.decode(header.slice(0, 100));
    var name = nameRaw.replace(/\0.*$/, '');

    // Check for prefix (bytes 345-499, ustar format)
    var prefix = decoder.decode(header.slice(345, 500)).replace(/\0.*$/, '');
    if (prefix) name = prefix + '/' + name;

    // Parse size (bytes 124-135, octal)
    var sizeStr = decoder.decode(header.slice(124, 136)).replace(/\0.*$/, '').trim();
    var size = parseInt(sizeStr, 8) || 0;

    // Parse type flag (byte 156)
    var typeFlag = String.fromCharCode(header[156]);

    offset += 512;

    if (size > 0 && (typeFlag === '0' || typeFlag === '\0' || typeFlag === '')) {
      files.set(name, tarBytes.slice(offset, offset + size));
    }

    // Advance past file data (padded to 512)
    offset += Math.ceil(size / 512) * 512;
  }
  return files;
}

// ═══════════════════════════════════════════════════════════════
// Data loading
// ═══════════════════════════════════════════════════════════════

function loadRollout(fileMap) {
  var decoder = new TextDecoder();

  // Helper to find a file by suffix (handles arbitrary directory prefix)
  function findFile(suffix) {
    for (var entry of fileMap) {
      if (entry[0].endsWith(suffix)) return entry[1];
    }
    return null;
  }

  function tryParseJSON(suffix) {
    var bytes = findFile(suffix);
    if (!bytes) return null;
    try { return JSON.parse(decoder.decode(bytes)); } catch(e) { return null; }
  }

  // Discover iteration numbers by finding dom_N.json files
  var iterNums = new Set();
  fileMap.forEach(function(_, name) {
    var m = name.match(/dom_(\d+)\.json$/);
    if (m) iterNums.add(parseInt(m[1], 10));
  });
  var sorted = Array.from(iterNums).sort(function(a, b) { return a - b; });

  if (sorted.length === 0) {
    throw new Error('No dom_N.json files found in the archive. Expected files like rollout/dom_0.json');
  }

  // Load optional global files
  var inputJSON = tryParseJSON('input.json');
  var inputElements = inputJSON && inputJSON.elements ? inputJSON.elements : null;

  // Load trace.jsonl → overrides per iteration
  var traceEntries = {};
  var traceBytes = findFile('trace.jsonl');
  if (traceBytes) {
    var traceText = decoder.decode(traceBytes);
    traceText.split('\n').forEach(function(line) {
      line = line.trim();
      if (!line) return;
      try {
        var entry = JSON.parse(line);
        if (entry.iter != null) traceEntries[entry.iter] = entry;
      } catch(e) {}
    });
  }

  var slideW = 1280, slideH = 720;
  var iterations = [];

  for (var ni = 0; ni < sorted.length; ni++) {
    var n = sorted[ni];
    var domBytes = findFile('dom_' + n + '.json');
    var diagBytes = findFile('diag_' + n + '.json');
    var htmlBytes = findFile('out_' + n + '.html');
    var pngBytes = findFile('render_' + n + '.png');

    if (!domBytes || !diagBytes) continue;

    var dom = JSON.parse(decoder.decode(domBytes));
    var diag = JSON.parse(decoder.decode(diagBytes));
    var rawHTML = htmlBytes ? decoder.decode(htmlBytes) : null;

    if (dom.slide) {
      slideW = dom.slide.w || slideW;
      slideH = dom.slide.h || slideH;
    }

    // Use real IR if available, otherwise synthesize from DOM
    var realIR = tryParseJSON('ir_' + n + '.json');
    var ir = realIR || syntheticIRFromDOM(dom, inputElements);

    // Load real patch if available
    var patch = tryParseJSON('patch_' + n + '.json');

    // Load overrides from trace
    var trace = traceEntries[n] || null;
    var overrides = trace && trace.overrides ? trace.overrides : null;

    var slideHTML = rawHTML ? extractSlideDiv(rawHTML) : '';

    var pngDataURI = null;
    if (pngBytes) {
      pngDataURI = uint8ToDataURI(pngBytes, 'image/png');
    }

    iterations.push({
      iter: n,
      dom: dom,
      diag: diag,
      ir: ir,
      patch: patch,
      overrides: overrides,
      slideHTML: slideHTML,
      pngDataURI: pngDataURI,
    });
  }

  return { iterations: iterations, slideW: slideW, slideH: slideH };
}

function uint8ToDataURI(bytes, mime) {
  var binary = '';
  var len = bytes.length;
  for (var i = 0; i < len; i++) {
    binary += String.fromCharCode(bytes[i]);
  }
  return 'data:' + mime + ';base64,' + btoa(binary);
}

// ═══════════════════════════════════════════════════════════════
// Ported from synthetic-ir.ts
// ═══════════════════════════════════════════════════════════════

function syntheticIRFromDOM(dom, inputElements) {
  var inputMap = {};
  if (inputElements) {
    for (var i = 0; i < inputElements.length; i++) {
      inputMap[inputElements[i].eid] = inputElements[i];
    }
  }
  var elements = dom.elements.map(function(domEl) {
    var input = inputMap[domEl.eid];
    return {
      eid: domEl.eid,
      type: (input && input.type) || 'text',
      priority: (input && input.priority != null) ? input.priority : 50,
      content: (input && input.content) || '',
      layout: {
        x: domEl.bbox.x,
        y: domEl.bbox.y,
        w: domEl.bbox.w,
        h: domEl.bbox.h,
        zIndex: domEl.zIndex,
      },
      style: {
        fontSize: domEl.computed ? domEl.computed.fontSize : undefined,
        lineHeight: domEl.computed ? domEl.computed.lineHeight : undefined,
        ...(input && input.style ? input.style : {}),
      },
    };
  });
  return {
    slide: { w: (dom.slide && dom.slide.w) || 1280, h: (dom.slide && dom.slide.h) || 720 },
    elements: elements,
  };
}

// ═══════════════════════════════════════════════════════════════
// Ported from geometry.ts
// ═══════════════════════════════════════════════════════════════

function intersectRects(a, b) {
  var x = Math.max(a.x, b.x);
  var y = Math.max(a.y, b.y);
  var right = Math.min(a.x + a.w, b.x + b.w);
  var bottom = Math.min(a.y + a.h, b.y + b.h);
  var w = right - x;
  var h = bottom - y;
  if (w <= 0 || h <= 0) return null;
  return { x: x, y: y, w: w, h: h };
}

// ═══════════════════════════════════════════════════════════════
// Ported helpers from visual-debug.ts
// ═══════════════════════════════════════════════════════════════

function escapeHtml(s) {
  return s.replace(/&/g, '&amp;').replace(/</g, '&lt;').replace(/>/g, '&gt;').replace(/"/g, '&quot;');
}

function extractSlideDiv(html) {
  var startMarker = '<div id="slide">';
  var startIdx = html.indexOf(startMarker);
  if (startIdx === -1) return '';
  var endMarker = '</div>\n</body>';
  var endIdx = html.indexOf(endMarker, startIdx);
  if (endIdx === -1) {
    var bodyEnd = html.indexOf('</body>');
    if (bodyEnd === -1) return '';
    return html.slice(startIdx, bodyEnd);
  }
  return html.slice(startIdx, endIdx + '</div>'.length);
}

function badgeColor(type) {
  switch (type) {
    case 'content_overflow': return '#dc2626';
    case 'out_of_bounds': return '#dc2626';
    case 'overlap': return '#ea580c';
    case 'font_too_small': return '#ca8a04';
    default: return '#6b7280';
  }
}

function defectLabel(d) {
  switch (d.type) {
    case 'content_overflow': {
      var det = d.details || {};
      var parts = [];
      if (det.overflow_x_px > 0) parts.push('\u2194' + Math.round(det.overflow_x_px) + 'px');
      if (det.overflow_y_px > 0) parts.push('\u2195' + Math.round(det.overflow_y_px) + 'px');
      return 'overflow ' + parts.join(' ');
    }
    case 'out_of_bounds': {
      var det = d.details || {};
      return 'out of bounds: ' + det.edge + ' +' + Math.round(det.by_px) + 'px';
    }
    case 'overlap': {
      var det = d.details || {};
      var other = d.other_eid ? ' vs ' + d.other_eid : '';
      return 'overlap' + other + ' ' + Math.round(det.overlap_area_px) + 'px\u00B2';
    }
    case 'font_too_small': {
      var det = d.details || {};
      return 'font ' + det.current + 'px < ' + det.min + 'px min';
    }
    default:
      return d.type;
  }
}

function svgRect(rect, opts) {
  var eidAttr = opts.eid ? ' data-eid="' + escapeHtml(opts.eid) + '"' : '';
  var dash = opts.dashArray ? ' stroke-dasharray="' + opts.dashArray + '"' : '';
  return '<rect data-layer="' + opts.layer + '"' + eidAttr +
    ' x="' + rect.x + '" y="' + rect.y + '" width="' + rect.w + '" height="' + rect.h + '"' +
    ' fill="' + opts.fill + '" stroke="' + opts.stroke + '" stroke-width="' + opts.strokeWidth + '"' + dash +
    ' pointer-events="all" />';
}

function buildOOBOverlay(edge, byPx, slideW, slideH, eid, domEl) {
  var parts = [];
  if (domEl) {
    var b = domEl.bbox;
    var oobRect = null;
    switch (edge) {
      case 'right':  oobRect = { x: slideW, y: b.y, w: byPx, h: b.h }; break;
      case 'left':   oobRect = { x: b.x, y: b.y, w: byPx, h: b.h }; break;
      case 'bottom': oobRect = { x: b.x, y: slideH, w: b.w, h: byPx }; break;
      case 'top':    oobRect = { x: b.x, y: b.y, w: b.w, h: byPx }; break;
    }
    if (oobRect) {
      parts.push(
        '<rect data-layer="oob" data-eid="' + escapeHtml(eid) + '"' +
        ' x="' + oobRect.x + '" y="' + oobRect.y + '" width="' + oobRect.w + '" height="' + oobRect.h + '"' +
        ' fill="rgba(239,68,68,0.2)" stroke="#ef4444" stroke-width="2" stroke-dasharray="4,2" />'
      );
      var step = 12;
      for (var offset = 0; offset < oobRect.w + oobRect.h; offset += step) {
        var lx1 = oobRect.x + Math.min(offset, oobRect.w);
        var ly1 = oobRect.y + Math.max(0, offset - oobRect.w);
        var lx2 = oobRect.x + Math.max(0, offset - oobRect.h);
        var ly2 = oobRect.y + Math.min(offset, oobRect.h);
        parts.push(
          '<line data-layer="oob" x1="' + lx1 + '" y1="' + ly1 + '" x2="' + lx2 + '" y2="' + ly2 + '"' +
          ' stroke="#ef4444" stroke-width="1" opacity="0.4" />'
        );
      }
    }
    var labelText = 'out of bounds: ' + edge + ' +' + Math.round(byPx) + 'px';
    var labelW = labelText.length * 6.5 + 12;
    var labelX, labelY;
    switch (edge) {
      case 'right':  labelX = slideW - labelW - 4; labelY = b.y - 22; break;
      case 'left':   labelX = 4; labelY = b.y - 22; break;
      case 'bottom': labelX = b.x; labelY = slideH - 22; break;
      case 'top':    labelX = b.x; labelY = 4; break;
      default:       labelX = b.x; labelY = b.y - 22;
    }
    parts.push(
      '<g data-layer="oob" data-eid="' + escapeHtml(eid) + '">' +
      '<rect x="' + labelX + '" y="' + labelY + '" width="' + labelW + '" height="18" rx="3" fill="#ef4444" opacity="0.9" />' +
      '<text x="' + (labelX + 6) + '" y="' + (labelY + 13) + '" fill="white" font-size="11" font-family="system-ui, sans-serif">' + escapeHtml(labelText) + '</text>' +
      '</g>'
    );
  } else {
    var x1 = 0, y1 = 0, x2 = 0, y2 = 0;
    switch (edge) {
      case 'left':   x2 = 0; y2 = slideH; break;
      case 'right':  x1 = slideW; x2 = slideW; y2 = slideH; break;
      case 'top':    x2 = slideW; break;
      case 'bottom': y1 = slideH; x2 = slideW; y2 = slideH; break;
    }
    parts.push(
      '<line data-layer="oob" data-eid="' + escapeHtml(eid) + '"' +
      ' x1="' + x1 + '" y1="' + y1 + '" x2="' + x2 + '" y2="' + y2 + '" stroke="#ef4444" stroke-width="3" />'
    );
  }
  return parts.join('\n            ');
}

// ═══════════════════════════════════════════════════════════════
// Build element data (from visual-debug.ts buildElementData)
// ═══════════════════════════════════════════════════════════════

// Compute a synthetic patch by diffing consecutive IRs
function computeSyntheticPatch(prevIR, currIR) {
  var prevMap = {};
  for (var i = 0; i < prevIR.elements.length; i++) {
    prevMap[prevIR.elements[i].eid] = prevIR.elements[i];
  }
  var edits = [];
  for (var i = 0; i < currIR.elements.length; i++) {
    var curr = currIR.elements[i];
    var prev = prevMap[curr.eid];
    if (!prev) continue;
    var layoutDiff = {};
    var styleDiff = {};
    var hasLayout = false;
    var hasStyle = false;
    // Compare layout fields
    var layoutKeys = ['x', 'y', 'w', 'h', 'zIndex'];
    for (var k = 0; k < layoutKeys.length; k++) {
      var key = layoutKeys[k];
      if (curr.layout[key] !== prev.layout[key]) {
        layoutDiff[key] = curr.layout[key];
        hasLayout = true;
      }
    }
    // Compare style fields
    var styleKeys = ['fontSize', 'lineHeight'];
    for (var k = 0; k < styleKeys.length; k++) {
      var key = styleKeys[k];
      if (curr.style && prev.style && curr.style[key] !== prev.style[key]) {
        styleDiff[key] = curr.style[key];
        hasStyle = true;
      }
    }
    if (hasLayout || hasStyle) {
      var edit = { eid: curr.eid };
      if (hasLayout) edit.layout = layoutDiff;
      if (hasStyle) edit.style = styleDiff;
      edits.push(edit);
    }
  }
  if (edits.length === 0) return null;
  return { edits: edits };
}

// Summarize diag hints as a readable "suggested changes" block
function summarizeHints(diag) {
  var hints = [];
  for (var i = 0; i < diag.defects.length; i++) {
    var d = diag.defects[i];
    if (!d.hint) continue;
    var h = d.hint;
    var eid = h.target_eid || d.eid || d.owner_eid || '?';
    var parts = [eid + ': ' + (h.action || '?')];
    if (h.suggested_x != null) parts.push('x\u2192' + Math.round(h.suggested_x));
    if (h.suggested_y != null) parts.push('y\u2192' + Math.round(h.suggested_y));
    if (h.suggested_w != null) parts.push('w\u2192' + Math.round(h.suggested_w));
    if (h.suggested_h != null) parts.push('h\u2192' + Math.round(h.suggested_h));
    if (h.reason) parts.push('(' + h.reason + ')');
    hints.push(parts.join(' '));
  }
  return hints;
}

function buildElementData(ir, dom, diag) {
  var irMap = {};
  for (var i = 0; i < ir.elements.length; i++) {
    irMap[ir.elements[i].eid] = ir.elements[i];
  }
  return dom.elements.map(function(domEl) {
    var irEl = irMap[domEl.eid];
    var defects = diag.defects
      .filter(function(d) { return d.eid === domEl.eid || d.owner_eid === domEl.eid; })
      .map(function(d) { return { type: d.type, severity: d.severity }; });
    return {
      eid: domEl.eid,
      type: irEl ? irEl.type : 'unknown',
      priority: irEl ? irEl.priority : 0,
      defects: defects,
      bbox: { x: domEl.bbox.x, y: domEl.bbox.y, w: domEl.bbox.w, h: domEl.bbox.h },
      fontSize: irEl && irEl.style ? irEl.style.fontSize : undefined,
    };
  });
}

// ═══════════════════════════════════════════════════════════════
// Build overlay SVG (from visual-debug.ts buildOverlaySVG)
// ═══════════════════════════════════════════════════════════════

function buildOverlaySVG(ir, dom, diag, slideW, slideH) {
  var parts = [];
  var irMap = {};
  for (var i = 0; i < ir.elements.length; i++) {
    irMap[ir.elements[i].eid] = ir.elements[i];
  }

  for (var i = 0; i < dom.elements.length; i++) {
    var domEl = dom.elements[i];
    var irEl = irMap[domEl.eid];
    if (!irEl) continue;

    // bbox
    parts.push(svgRect(domEl.bbox, {
      stroke: '#3b82f6', strokeWidth: 1, fill: 'none',
      dashArray: undefined, layer: 'bbox', eid: domEl.eid,
    }));

    // safeBox
    parts.push(svgRect(domEl.safeBox, {
      stroke: '#8b5cf6', strokeWidth: 1, fill: 'none',
      dashArray: '4,3', layer: 'safebox', eid: domEl.eid,
    }));

    // contentBox
    if (domEl.contentBox) {
      var hasOverflow = diag.defects.some(function(d) {
        return d.type === 'content_overflow' && (d.eid === domEl.eid || d.owner_eid === domEl.eid);
      });
      parts.push(svgRect(domEl.contentBox, {
        stroke: hasOverflow ? '#ef4444' : '#22c55e',
        strokeWidth: hasOverflow ? 2 : 1,
        fill: 'none', dashArray: '2,2',
        layer: 'contentbox', eid: domEl.eid,
      }));
    }
  }

  // Overlap zones
  var overlapDefects = diag.defects.filter(function(d) { return d.type === 'overlap'; });
  for (var i = 0; i < overlapDefects.length; i++) {
    var defect = overlapDefects[i];
    var ownerDom = dom.elements.find(function(e) { return e.eid === defect.owner_eid; });
    var otherDom = dom.elements.find(function(e) { return e.eid === defect.other_eid; });
    if (ownerDom && otherDom) {
      var inter = intersectRects(ownerDom.safeBox, otherDom.safeBox);
      if (inter) {
        parts.push(svgRect(inter, {
          stroke: 'none', strokeWidth: 0,
          fill: 'rgba(239,68,68,0.25)',
          dashArray: undefined, layer: 'overlap',
        }));
      }
    }
  }

  // OOB
  for (var i = 0; i < diag.defects.length; i++) {
    var defect = diag.defects[i];
    if (defect.type !== 'out_of_bounds') continue;
    var details = defect.details || {};
    var eid = defect.eid || defect.owner_eid || '';
    var domEl = dom.elements.find(function(e) { return e.eid === eid; });
    parts.push(buildOOBOverlay(details.edge, details.by_px, slideW, slideH, eid, domEl));
  }

  // Defect labels
  for (var i = 0; i < dom.elements.length; i++) {
    var domEl = dom.elements[i];
    var defects = diag.defects.filter(function(d) {
      return d.eid === domEl.eid || d.owner_eid === domEl.eid;
    });
    if (defects.length === 0) continue;
    var b = domEl.bbox;
    var badgeX = b.x + b.w + 20;
    var badgeY = b.y;
    parts.push('<g class="defect-group" data-layer="badge" data-defect-eid="' + escapeHtml(domEl.eid) + '">');

    parts.push(
      '<rect x="' + (b.x - 1) + '" y="' + (b.y - 1) + '" width="' + (b.w + 2) + '" height="' + (b.h + 2) + '"' +
      ' fill="none" stroke="#ef4444" stroke-width="2.5" stroke-dasharray="6,3" />'
    );

    for (var j = 0; j < defects.length; j++) {
      var d = defects[j];
      var color = badgeColor(d.type);
      var label = defectLabel(d);
      var yOff = badgeY + j * 22;
      var textW = label.length * 6.5 + 12;

      parts.push(
        '<line x1="' + (b.x + b.w) + '" y1="' + (yOff + 9) + '" x2="' + badgeX + '" y2="' + (yOff + 9) + '"' +
        ' stroke="' + color + '" stroke-width="1" stroke-dasharray="3,2" />'
      );
      parts.push(
        '<rect x="' + badgeX + '" y="' + yOff + '" width="' + textW + '" height="18" rx="3" fill="' + color + '" opacity="0.92" />' +
        '<text x="' + (badgeX + 6) + '" y="' + (yOff + 13) + '" fill="white" font-size="11" font-family="system-ui, sans-serif">' + escapeHtml(label) + '</text>'
      );

      // Inline problem-area visualizations
      if (d.type === 'overlap') {
        var otherDom = dom.elements.find(function(e) { return e.eid === d.other_eid; });
        if (otherDom) {
          var inter = intersectRects(domEl.safeBox, otherDom.safeBox);
          if (inter) {
            parts.push(
              '<rect x="' + inter.x + '" y="' + inter.y + '" width="' + inter.w + '" height="' + inter.h + '"' +
              ' fill="rgba(239,68,68,0.3)" stroke="#ef4444" stroke-width="1.5" />'
            );
            var step = 8;
            for (var off = 0; off < inter.w + inter.h; off += step) {
              var lx1 = inter.x + Math.min(off, inter.w);
              var ly1 = inter.y + Math.max(0, off - inter.w);
              var lx2 = inter.x + Math.max(0, off - inter.h);
              var ly2 = inter.y + Math.min(off, inter.h);
              parts.push(
                '<line x1="' + lx1 + '" y1="' + ly1 + '" x2="' + lx2 + '" y2="' + ly2 + '"' +
                ' stroke="#ef4444" stroke-width="0.7" opacity="0.5" />'
              );
            }
          }
          var ob = otherDom.bbox;
          parts.push(
            '<rect x="' + (ob.x - 1) + '" y="' + (ob.y - 1) + '" width="' + (ob.w + 2) + '" height="' + (ob.h + 2) + '"' +
            ' fill="none" stroke="#f97316" stroke-width="1.5" stroke-dasharray="5,3" />'
          );
          var midX = (b.x + b.w / 2 + ob.x + ob.w / 2) / 2;
          var midY = (b.y + b.h / 2 + ob.y + ob.h / 2) / 2;
          parts.push(
            '<rect x="' + (midX - 18) + '" y="' + (midY - 8) + '" width="36" height="16" rx="3" fill="#ef4444" opacity="0.85" />' +
            '<text x="' + midX + '" y="' + (midY + 4) + '" fill="white" font-size="9" font-weight="bold"' +
            ' font-family="system-ui, sans-serif" text-anchor="middle">overlap</text>'
          );
        }
      } else if (d.type === 'content_overflow') {
        var det = d.details || {};
        if (det.overflow_y_px > 0) {
          parts.push(
            '<rect x="' + b.x + '" y="' + (b.y + b.h) + '" width="' + b.w + '" height="' + det.overflow_y_px + '"' +
            ' fill="rgba(239,68,68,0.15)" stroke="#ef4444" stroke-width="1.5" stroke-dasharray="4,2" />'
          );
          var arrowX = b.x + b.w / 2;
          parts.push(
            '<line x1="' + arrowX + '" y1="' + (b.y + b.h) + '" x2="' + arrowX + '" y2="' + (b.y + b.h + det.overflow_y_px) + '"' +
            ' stroke="#ef4444" stroke-width="1.5" marker-end="url(#overflow-arrow)" />'
          );
          parts.push(
            '<rect x="' + (arrowX + 6) + '" y="' + (b.y + b.h + det.overflow_y_px / 2 - 7) + '" width="50" height="14" rx="2" fill="#dc2626" opacity="0.85" />' +
            '<text x="' + (arrowX + 10) + '" y="' + (b.y + b.h + det.overflow_y_px / 2 + 4) + '" fill="white" font-size="9"' +
            ' font-family="system-ui, sans-serif">+' + Math.round(det.overflow_y_px) + 'px</text>'
          );
        }
        if (det.overflow_x_px > 0) {
          parts.push(
            '<rect x="' + (b.x + b.w) + '" y="' + b.y + '" width="' + det.overflow_x_px + '" height="' + b.h + '"' +
            ' fill="rgba(239,68,68,0.15)" stroke="#ef4444" stroke-width="1.5" stroke-dasharray="4,2" />'
          );
          var arrowY = b.y + b.h / 2;
          parts.push(
            '<line x1="' + (b.x + b.w) + '" y1="' + arrowY + '" x2="' + (b.x + b.w + det.overflow_x_px) + '" y2="' + arrowY + '"' +
            ' stroke="#ef4444" stroke-width="1.5" marker-end="url(#overflow-arrow)" />'
          );
        }
      }
    }
    parts.push('</g>');
  }

  // Hint ghost rectangles
  for (var i = 0; i < diag.defects.length; i++) {
    var defect = diag.defects[i];
    if (!defect.hint) continue;
    var hint = defect.hint;
    if (hint.suggested_x == null && hint.suggested_y == null && hint.suggested_w == null && hint.suggested_h == null) continue;
    var eid = defect.eid || defect.owner_eid || (hint.target_eid || '');
    var domEl = dom.elements.find(function(e) { return e.eid === (hint.target_eid || eid); });
    if (!domEl) continue;
    var ghostRect = {
      x: hint.suggested_x != null ? hint.suggested_x : domEl.bbox.x,
      y: hint.suggested_y != null ? hint.suggested_y : domEl.bbox.y,
      w: hint.suggested_w != null ? hint.suggested_w : domEl.bbox.w,
      h: hint.suggested_h != null ? hint.suggested_h : domEl.bbox.h,
    };
    parts.push(svgRect(ghostRect, {
      stroke: '#22c55e', strokeWidth: 2,
      fill: 'rgba(34,197,94,0.1)', dashArray: '6,3',
      layer: 'hint', eid: eid,
    }));
  }

  return parts.join('\n            ');
}

// ═══════════════════════════════════════════════════════════════
// Build diff overlay (from visual-debug.ts buildDiffOverlay)
// ═══════════════════════════════════════════════════════════════

function buildDiffOverlay(prevIR, prevDiag, currIR, currDiag, slideW, slideH) {
  var parts = [];
  var prevIRMap = {};
  for (var i = 0; i < prevIR.elements.length; i++) prevIRMap[prevIR.elements[i].eid] = prevIR.elements[i];
  var currIRMap = {};
  for (var i = 0; i < currIR.elements.length; i++) currIRMap[currIR.elements[i].eid] = currIR.elements[i];

  var prevSev = {};
  for (var i = 0; i < prevDiag.defects.length; i++) {
    var d = prevDiag.defects[i];
    var eid = d.eid || d.owner_eid || '';
    prevSev[eid] = (prevSev[eid] || 0) + d.severity;
  }
  var currSev = {};
  for (var i = 0; i < currDiag.defects.length; i++) {
    var d = currDiag.defects[i];
    var eid = d.eid || d.owner_eid || '';
    currSev[eid] = (currSev[eid] || 0) + d.severity;
  }

  var hintMap = {};
  for (var i = 0; i < prevDiag.defects.length; i++) {
    var d = prevDiag.defects[i];
    if (!d.hint) continue;
    var eid = d.hint.target_eid || d.eid || d.owner_eid || '';
    if (!hintMap[eid]) hintMap[eid] = d.hint;
  }

  var tagW = 46;
  var tagColor = '#a78bfa';

  parts.push('<g data-layer="diff">');

  for (var i = 0; i < currIR.elements.length; i++) {
    var currEl = currIR.elements[i];
    var prevEl = prevIRMap[currEl.eid];
    if (!prevEl) continue;

    var pl = prevEl.layout;
    var cl = currEl.layout;
    var improved = (currSev[currEl.eid] || 0) < (prevSev[currEl.eid] || 0);
    var color = improved ? '#22c55e' : '#ef4444';
    var hint = hintMap[currEl.eid];

    var hasMoved = pl.x !== cl.x || pl.y !== cl.y;
    var hasResized = pl.w !== cl.w || pl.h !== cl.h;
    var hasFontChange = prevEl.style.fontSize != null && currEl.style.fontSize != null &&
      prevEl.style.fontSize !== currEl.style.fontSize;

    if (!hasMoved && !hasResized && !hasFontChange) continue;

    if (hasMoved || hasResized) {
      parts.push(
        '<rect x="' + pl.x + '" y="' + pl.y + '" width="' + pl.w + '" height="' + pl.h + '"' +
        ' fill="none" stroke="' + color + '" stroke-width="1.5" stroke-dasharray="4,3" opacity="0.5" />'
      );
    }

    if (hasMoved) {
      var oldCX = pl.x + pl.w / 2;
      var oldCY = pl.y + pl.h / 2;
      var newCX = cl.x + cl.w / 2;
      var newCY = cl.y + cl.h / 2;
      parts.push(
        '<line x1="' + oldCX + '" y1="' + oldCY + '" x2="' + newCX + '" y2="' + newCY + '"' +
        ' stroke="' + color + '" stroke-width="2" marker-end="url(#diff-arrow-' + (improved ? 'g' : 'r') + ')" />'
      );
      var labels = [];
      if (pl.x !== cl.x) labels.push('x: ' + Math.round(pl.x) + '\u2192' + Math.round(cl.x));
      if (pl.y !== cl.y) labels.push('y: ' + Math.round(pl.y) + '\u2192' + Math.round(cl.y));
      var labelText = labels.join('  ');
      var lx = (oldCX + newCX) / 2 + 6;
      var ly = (oldCY + newCY) / 2 - 6;
      var lw = labelText.length * 6 + tagW + 14;
      parts.push(
        '<rect x="' + lx + '" y="' + (ly - 10) + '" width="' + lw + '" height="14" rx="2" fill="rgba(255,255,255,0.9)" />' +
        '<rect x="' + lx + '" y="' + (ly - 10) + '" width="' + tagW + '" height="14" rx="2" fill="' + tagColor + '" />' +
        '<text x="' + (lx + 3) + '" y="' + (ly + 1) + '" fill="white" font-size="9" font-weight="bold" font-family="system-ui, sans-serif">ACTUAL</text>' +
        '<text x="' + (lx + tagW + 5) + '" y="' + (ly + 1) + '" fill="' + color + '" font-size="10" font-family="system-ui, sans-serif">' + escapeHtml(labelText) + '</text>'
      );

      if (hint) {
        var hintParts = [];
        if (hint.suggested_x != null && pl.x !== cl.x) {
          var hintVal = Math.round(hint.suggested_x);
          var actualVal = Math.round(cl.x);
          if (hintVal !== actualVal) hintParts.push('x: hint ' + hintVal + ' vs actual ' + actualVal);
        }
        if (hint.suggested_y != null && pl.y !== cl.y) {
          var hintVal = Math.round(hint.suggested_y);
          var actualVal = Math.round(cl.y);
          if (hintVal !== actualVal) hintParts.push('y: hint ' + hintVal + ' vs actual ' + actualVal);
        }
        if (hintParts.length > 0) {
          var cmpText = hintParts.join('  ');
          var cmpLw = cmpText.length * 5.5 + 10;
          var cmpY = ly + 6;
          parts.push(
            '<rect x="' + lx + '" y="' + cmpY + '" width="' + cmpLw + '" height="12" rx="2" fill="rgba(167,139,250,0.15)" stroke="' + tagColor + '" stroke-width="0.5" />' +
            '<text x="' + (lx + 5) + '" y="' + (cmpY + 9) + '" fill="' + tagColor + '" font-size="9" font-family="system-ui, sans-serif">' + escapeHtml(cmpText) + '</text>'
          );
        }
      }
    }

    if (hasResized) {
      var labels = [];
      if (pl.w !== cl.w) labels.push('w: ' + Math.round(pl.w) + '\u2192' + Math.round(cl.w));
      if (pl.h !== cl.h) labels.push('h: ' + Math.round(pl.h) + '\u2192' + Math.round(cl.h));
      var labelText = labels.join('  ');
      var lx = cl.x + cl.w + 4;
      var ly = cl.y + cl.h / 2;
      var lw = labelText.length * 6 + tagW + 14;
      parts.push(
        '<rect x="' + lx + '" y="' + (ly - 8) + '" width="' + lw + '" height="14" rx="2" fill="rgba(255,255,255,0.9)" />' +
        '<rect x="' + lx + '" y="' + (ly - 8) + '" width="' + tagW + '" height="14" rx="2" fill="' + tagColor + '" />' +
        '<text x="' + (lx + 3) + '" y="' + (ly + 3) + '" fill="white" font-size="9" font-weight="bold" font-family="system-ui, sans-serif">ACTUAL</text>' +
        '<text x="' + (lx + tagW + 5) + '" y="' + (ly + 3) + '" fill="' + color + '" font-size="10" font-family="system-ui, sans-serif">' + escapeHtml(labelText) + '</text>'
      );

      if (hint) {
        var hintParts = [];
        if (hint.suggested_w != null && pl.w !== cl.w) {
          var hintVal = Math.round(hint.suggested_w);
          var actualVal = Math.round(cl.w);
          if (hintVal !== actualVal) hintParts.push('w: hint ' + hintVal + ' vs actual ' + actualVal);
        }
        if (hint.suggested_h != null && pl.h !== cl.h) {
          var hintVal = Math.round(hint.suggested_h);
          var actualVal = Math.round(cl.h);
          if (hintVal !== actualVal) hintParts.push('h: hint ' + hintVal + ' vs actual ' + actualVal);
        }
        if (hintParts.length > 0) {
          var cmpText = hintParts.join('  ');
          var cmpLw = cmpText.length * 5.5 + 10;
          var cmpY = ly + 8;
          parts.push(
            '<rect x="' + lx + '" y="' + cmpY + '" width="' + cmpLw + '" height="12" rx="2" fill="rgba(167,139,250,0.15)" stroke="' + tagColor + '" stroke-width="0.5" />' +
            '<text x="' + (lx + 5) + '" y="' + (cmpY + 9) + '" fill="' + tagColor + '" font-size="9" font-family="system-ui, sans-serif">' + escapeHtml(cmpText) + '</text>'
          );
        }
      }
    }

    if (hasFontChange) {
      var oldFs = prevEl.style.fontSize;
      var newFs = currEl.style.fontSize;
      var fontColor = newFs > oldFs ? '#22c55e' : '#ef4444';
      var badgeText = oldFs + 'px\u2192' + newFs + 'px';
      var bx = cl.x;
      var by = cl.y - 16;
      var bw = badgeText.length * 6.5 + 10;
      parts.push(
        '<rect x="' + bx + '" y="' + by + '" width="' + bw + '" height="14" rx="3" fill="' + fontColor + '" opacity="0.85" />' +
        '<text x="' + (bx + 5) + '" y="' + (by + 11) + '" fill="white" font-size="10" font-family="system-ui, sans-serif">' + escapeHtml(badgeText) + '</text>'
      );
    }
  }

  parts.push('</g>');
  return parts.join('\n            ');
}

// ═══════════════════════════════════════════════════════════════
// Build the viewer UI
// ═══════════════════════════════════════════════════════════════

function buildViewer(rollout) {
  var iterations = rollout.iterations;
  var slideW = rollout.slideW;
  var slideH = rollout.slideH;

  // Build per-iteration data
  var iterData = [];
  for (var i = 0; i < iterations.length; i++) {
    var it = iterations[i];
    var overlays = buildOverlaySVG(it.ir, it.dom, it.diag, slideW, slideH);
    if (i > 0) {
      var prev = iterations[i - 1];
      overlays += buildDiffOverlay(prev.ir, prev.diag, it.ir, it.diag, slideW, slideH);
    }
    // Patch: use real patch if available, else compute from IR diff
    var patchJSON = null;
    if (it.patch) {
      patchJSON = JSON.stringify(it.patch, null, 2);
    } else if (i > 0) {
      var synPatch = computeSyntheticPatch(iterations[i - 1].ir, it.ir);
      if (synPatch) {
        patchJSON = '// Computed from DOM diff (no patch_N.json in archive)\n' +
          JSON.stringify(synPatch, null, 2);
      } else {
        patchJSON = '(no changes detected vs previous iteration)';
      }
    } else {
      patchJSON = '(initial iteration \u2014 no patch)';
    }

    // Overrides: use real overrides if available, else show current iter's hints
    var overridesJSON = null;
    if (it.overrides) {
      overridesJSON = JSON.stringify(it.overrides, null, 2);
    } else {
      var curHints = summarizeHints(it.diag);
      if (curHints.length > 0) {
        overridesJSON = '// Diagnostic hints for this iteration (' + curHints.length + ' suggestions)\n// (no trace.jsonl in archive for real overrides)\n\n' +
          curHints.join('\n');
      } else {
        overridesJSON = '(no defect hints for this iteration)';
      }
    }

    iterData.push({
      iter: it.iter,
      slideHTML: it.slideHTML,
      overlays: overlays,
      diagJSON: JSON.stringify(it.diag, null, 2),
      patchJSON: patchJSON,
      overridesJSON: overridesJSON,
      elements: buildElementData(it.ir, it.dom, it.diag),
      summary: it.diag.summary,
      dom: it.dom,
      fingerprint: null,
      tabooFingerprints: [],
    });
  }

  // Store globally for the viewer logic
  window.iterDataMeta = iterData;

  // Build HTML
  var app = document.getElementById('app');
  app.style.display = 'flex';

  // Toolbar
  var tabsHTML = '';
  for (var i = 0; i < iterData.length; i++) {
    var d = iterData[i];
    tabsHTML += '<button class="tab' + (i === 0 ? ' active' : '') + '" data-iter="' + i + '" onclick="switchIter(' + i + ')">Iter ' + d.iter + (i === 0 ? ' (initial)' : '') + '<span class="tab-badge">' + d.summary.defect_count + 'D / ' + d.summary.warning_count + 'W</span></button>';
  }

  // Timeline markers
  var markersHTML = '';
  for (var i = 0; i < iterData.length; i++) {
    var d = iterData[i];
    markersHTML += '<div class="timeline-marker' + (i === 0 ? ' active' : '') + '" data-idx="' + i + '" onclick="jumpTo(' + i + ')" title="Iter ' + d.iter + '">' +
      '<span class="marker-dot"></span>' +
      '<span class="marker-label">Iter ' + d.iter + '</span>' +
      '<span class="marker-badge">' + d.summary.defect_count + 'D</span>' +
      '</div>';
  }

  // Slide iterations
  var slidesHTML = '';
  for (var i = 0; i < iterData.length; i++) {
    var d = iterData[i];
    slidesHTML += '<div class="iter-slide" data-iter="' + i + '" style="display:' + (i === 0 ? 'block' : 'none') + '">' +
      '<div class="slide-base">' + d.slideHTML + '</div>' +
      '<svg class="overlay-svg" width="' + slideW + '" height="' + slideH + '" viewBox="0 0 ' + slideW + ' ' + slideH + '">' +
      '<defs>' +
      '<marker id="diff-arrow-g" markerWidth="8" markerHeight="6" refX="8" refY="3" orient="auto"><polygon points="0 0, 8 3, 0 6" fill="#22c55e" /></marker>' +
      '<marker id="diff-arrow-r" markerWidth="8" markerHeight="6" refX="8" refY="3" orient="auto"><polygon points="0 0, 8 3, 0 6" fill="#ef4444" /></marker>' +
      '</defs>' +
      d.overlays +
      '</svg>' +
      '</div>';
  }

  app.innerHTML =
    '<div id="toolbar">' +
      '<h1>PPTAgent Visual Debug</h1>' +
      '<div id="tabs">' + tabsHTML + '</div>' +
      '<div id="toggles">' +
        '<label style="font-weight:bold;border-right:1px solid #e2e8f0;padding-right:8px;margin-right:4px"><input type="checkbox" checked id="toggle-invert" onchange="invertAll()"> all</label>' +
        '<label><input type="checkbox" checked data-layer="bbox" onchange="toggleLayer(\'bbox\', this.checked)"> <span class="swatch" style="border:2px solid #3b82f6"></span> bbox</label>' +
        '<label><input type="checkbox" checked data-layer="safebox" onchange="toggleLayer(\'safebox\', this.checked)"> <span class="swatch" style="border:2px dashed #8b5cf6"></span> safeBox</label>' +
        '<label><input type="checkbox" checked data-layer="contentbox" onchange="toggleLayer(\'contentbox\', this.checked)"> <span class="swatch" style="border:2px dotted #22c55e"></span> contentBox</label>' +
        '<label><input type="checkbox" checked data-layer="overlap" onchange="toggleLayer(\'overlap\', this.checked)"> <span class="swatch" style="background:rgba(239,68,68,0.25)"></span> overlaps</label>' +
        '<label><input type="checkbox" checked data-layer="oob" onchange="toggleLayer(\'oob\', this.checked)"> <span class="swatch" style="border:2px solid #ef4444"></span> out of bounds</label>' +
        '<label><input type="checkbox" checked data-layer="badge" onchange="toggleLayer(\'badge\', this.checked)"> <span class="swatch" style="background:#dc2626;color:#fff;font-size:9px;padding:0 3px">!</span> defect labels</label>' +
        '<label><input type="checkbox" checked data-layer="hint" onchange="toggleLayer(\'hint\', this.checked)"> <span class="swatch" style="border:2px dashed #22c55e"></span> hints</label>' +
        '<label><input type="checkbox" checked data-layer="diff" onchange="toggleLayer(\'diff\', this.checked)"> <span class="swatch" style="border:2px solid #a78bfa"></span> diff</label>' +
      '</div>' +
    '</div>' +
    '<div id="timeline">' +
      '<div id="timeline-controls">' +
        '<button id="btn-step-back" onclick="stepBack()" title="Previous (\u2190)">\u25C1</button>' +
        '<button id="btn-play" onclick="togglePlay()" title="Play/Pause (Space)">\u25B6</button>' +
        '<button id="btn-step-fwd" onclick="stepForward()" title="Next (\u2192)">\u25B7</button>' +
        '<select id="speed-select" onchange="setSpeed(+this.value)">' +
          '<option value="500">0.5s</option>' +
          '<option value="1000" selected>1s</option>' +
          '<option value="2000">2s</option>' +
        '</select>' +
      '</div>' +
      '<div id="timeline-track">' +
        '<div id="timeline-progress"></div>' +
        markersHTML +
      '</div>' +
    '</div>' +
    '<div id="main">' +
      '<div id="slide-area">' +
        '<div id="slide-container" style="width:' + slideW + 'px;height:' + slideH + 'px;">' +
          slidesHTML +
          '<div id="anim-layer"></div>' +
        '</div>' +
        '<div id="tooltip"></div>' +
      '</div>' +
      '<div id="panel">' +
        '<div id="panel-header">' +
          '<div id="panel-tabs">' +
            '<button class="panel-tab active" data-ptab="diag" onclick="switchPanelTab(\'diag\')">Diagnostics</button>' +
            '<button class="panel-tab" data-ptab="patch" onclick="switchPanelTab(\'patch\')">Patch</button>' +
            '<button class="panel-tab" data-ptab="overrides" onclick="switchPanelTab(\'overrides\')">Hints</button>' +
          '</div>' +
          '<button onclick="togglePanel()" style="margin-left:auto;flex-shrink:0">\u2715</button>' +
        '</div>' +
        '<pre id="panel-content">' + escapeHtml(iterData[0].diagJSON) + '</pre>' +
      '</div>' +
    '</div>' +
    '<div id="conflict-bar"></div>';

  updateConflictBar();
}

// ═══════════════════════════════════════════════════════════════
// Viewer interactivity (from visual-debug.ts inline JS)
// ═══════════════════════════════════════════════════════════════

var currentIter = 0;
var activePanelTab = 'diag';
var playing = false;
var playTimer = null;
var playSpeed = 1000;
var animating = false;

function switchPanelTab(tab) {
  activePanelTab = tab;
  document.querySelectorAll('.panel-tab').forEach(function(b) { b.classList.remove('active'); });
  var target = document.querySelector('.panel-tab[data-ptab="' + tab + '"]');
  if (target) target.classList.add('active');
  updatePanelContent();
}

function updatePanelContent() {
  var meta = window.iterDataMeta[currentIter];
  var content = '';
  if (activePanelTab === 'diag') {
    content = meta.diagJSON;
  } else if (activePanelTab === 'patch') {
    content = meta.patchJSON;
  } else if (activePanelTab === 'overrides') {
    content = meta.overridesJSON;
  }
  document.getElementById('panel-content').textContent = content;
}

function switchIter(idx) {
  currentIter = idx;
  document.querySelectorAll('.tab').forEach(function(t) { t.classList.remove('active'); });
  var tabs = document.querySelectorAll('.tab');
  if (tabs[idx]) tabs[idx].classList.add('active');
  document.querySelectorAll('.iter-slide').forEach(function(s) {
    s.style.display = s.dataset.iter == idx ? 'block' : 'none';
  });
  document.querySelectorAll('.timeline-marker').forEach(function(m) {
    m.classList.toggle('active', +m.dataset.idx === idx);
  });
  var total = window.iterDataMeta.length - 1;
  var pct = total > 0 ? (idx / total * 100) : 0;
  document.getElementById('timeline-progress').style.width = pct + '%';
  updatePanelContent();
  updateConflictBar();
}

function invertAll() {
  var boxes = document.querySelectorAll('#toggles input[data-layer]');
  boxes.forEach(function(cb) {
    cb.checked = !cb.checked;
    toggleLayer(cb.getAttribute('data-layer'), cb.checked);
  });
}

function toggleLayer(layer, show) {
  var slides = document.querySelectorAll('.iter-slide');
  slides.forEach(function(s) {
    s.querySelectorAll('[data-layer="' + layer + '"]').forEach(function(el) {
      el.style.display = show ? '' : 'none';
    });
  });
}

function togglePanel() {
  var panel = document.getElementById('panel');
  panel.classList.toggle('collapsed');
}

// ── Animation layer ──
var typeColors = { text: '#3b82f6', title: '#3b82f6', bullets: '#3b82f6', image: '#22c55e', decoration: '#6b7280' };

function transitionTo(targetIdx) {
  if (animating || targetIdx < 0 || targetIdx >= window.iterDataMeta.length) return;
  if (targetIdx === currentIter) return;
  var fromIdx = currentIter;
  if (Math.abs(targetIdx - fromIdx) > 1) {
    switchIter(targetIdx);
    return;
  }
  animating = true;
  var fromElems = window.iterDataMeta[fromIdx].elements;
  var toElems = window.iterDataMeta[targetIdx].elements;
  var layer = document.getElementById('anim-layer');
  layer.innerHTML = '';

  var rects = [];
  for (var i = 0; i < fromElems.length; i++) {
    var fe = fromElems[i];
    var te = null;
    for (var j = 0; j < toElems.length; j++) {
      if (toElems[j].eid === fe.eid) { te = toElems[j]; break; }
    }
    if (!te) continue;
    var div = document.createElement('div');
    div.className = 'anim-rect';
    var c = typeColors[fe.type] || '#6b7280';
    div.style.cssText = 'position:absolute;border:2px solid ' + c + ';background:' + c + '20;' +
      'left:' + fe.bbox.x + 'px;top:' + fe.bbox.y + 'px;width:' + fe.bbox.w + 'px;height:' + fe.bbox.h + 'px;' +
      'transition:all 0.4s ease-in-out;pointer-events:none;border-radius:3px;';
    var label = document.createElement('span');
    label.style.cssText = 'position:absolute;top:2px;left:4px;font-size:9px;color:' + c + ';font-family:monospace;opacity:0.8;';
    label.textContent = fe.eid;
    div.appendChild(label);
    layer.appendChild(div);
    rects.push({ div: div, target: te.bbox });
  }

  layer.style.display = 'block';
  void layer.offsetHeight;
  for (var k = 0; k < rects.length; k++) {
    var r = rects[k];
    r.div.style.left = r.target.x + 'px';
    r.div.style.top = r.target.y + 'px';
    r.div.style.width = r.target.w + 'px';
    r.div.style.height = r.target.h + 'px';
  }

  setTimeout(function() {
    layer.style.display = 'none';
    layer.innerHTML = '';
    switchIter(targetIdx);
    animating = false;
  }, 450);
}

// ── Play/Pause ──
function togglePlay() {
  if (playing) {
    stopPlay();
  } else {
    playing = true;
    document.getElementById('btn-play').textContent = '\u23F8';
    advancePlay();
  }
}

function advancePlay() {
  if (!playing) return;
  var next = currentIter + 1;
  if (next >= window.iterDataMeta.length) {
    stopPlay();
    return;
  }
  transitionTo(next);
  playTimer = setTimeout(advancePlay, playSpeed + 500);
}

function stopPlay() {
  playing = false;
  if (playTimer) { clearTimeout(playTimer); playTimer = null; }
  var btn = document.getElementById('btn-play');
  if (btn) btn.textContent = '\u25B6';
}

function setSpeed(ms) {
  playSpeed = ms;
}

// ── Conflict bar ──
function updateConflictBar() {
  window.activeGroupEl = null;
  clearChain();
  var bar = document.getElementById('conflict-bar');
  if (!bar || !window.iterDataMeta) return;
  var meta = window.iterDataMeta[currentIter];
  var graph = (meta.summary && meta.summary.conflict_graph) || [];
  if (graph.length === 0) {
    bar.className = '';
    bar.innerHTML = '';
    return;
  }
  bar.className = 'visible';
  var html = '';
  for (var ci = 0; ci < graph.length; ci++) {
    var comp = graph[ci];
    var eidsAttr = comp.eids.map(escapeHtml).join(',');

    var edgeLines = '';
    for (var ei = 0; ei < comp.edges.length; ei++) {
      var e = comp.edges[ei];
      var best = e.separations[0];
      var alts = e.separations.slice(1).map(function(s) {
        return s.direction.replace('move_', '') + ' ' + s.cost_px + 'px';
      }).join(', ');
      var edgeText = escapeHtml(e.owner_eid + ' \u2192 ' + e.other_eid + ': ' +
        (best ? best.direction.replace('move_', '') + ' ' + best.cost_px + 'px' : '?') +
        (alts ? ' (or: ' + alts + ')' : ''));
      edgeLines += '<div class="cb-edge">' + edgeText + '</div>';
    }

    var envParts = [];
    for (var ei = 0; ei < comp.envelopes.length; ei++) {
      var env = comp.envelopes[ei];
      envParts.push(env.eid + ' \u2191' + env.free_top + ' \u2193' + env.free_bottom +
        ' \u2190' + env.free_left + ' \u2192' + env.free_right);
    }
    var envText = envParts.length > 0 ? '<div class="cb-env">Space: ' + escapeHtml(envParts.join(' | ')) + '</div>' : '';

    html += '<div class="cb-group" data-group-eids="' + eidsAttr + '">' +
      '<div class="cb-group-header">Group ' + (ci + 1) + ' (' + comp.eids.length + ' elem, ' + comp.edges.length + ' edge' + (comp.edges.length !== 1 ? 's' : '') + ')</div>' +
      edgeLines + envText + '</div>';
  }
  bar.innerHTML = html;
}

// ── Multi-rollout management ──
window.rollouts = [];
window.activeRolloutId = null;
window.nextRolloutId = 1;

function renderSidebar() {
  var list = document.getElementById('rollout-list');
  var html = '';
  for (var i = 0; i < window.rollouts.length; i++) {
    var r = window.rollouts[i];
    var isActive = r.id === window.activeRolloutId;
    var cls = 'rollout-card' + (isActive ? ' active' : '') + (r.loading ? ' rollout-card-loading' : '');
    var info = '';
    if (r.loading) {
      info = 'Loading\u2026';
    } else if (r.rollout) {
      var iters = r.rollout.iterations;
      var nIters = iters.length;
      var firstD = iters[0].diag.summary.defect_count;
      var lastD = iters[nIters - 1].diag.summary.defect_count;
      info = nIters + ' iteration' + (nIters !== 1 ? 's' : '') + ' &middot; ' + firstD + 'D &rarr; ' + lastD + 'D';
    }
    html += '<div class="' + cls + '" data-rollout-id="' + r.id + '" onclick="selectRollout(' + r.id + ')">' +
      '<div class="rollout-card-name">' + escapeHtml(r.name) + '</div>' +
      '<div class="rollout-card-info">' + info + '</div>' +
      '<button class="rollout-card-delete" onclick="event.stopPropagation();removeRollout(' + r.id + ')" title="Remove">&times;</button>';
    if (!r.loading && r.rollout) {
      html += '<label class="rollout-card-toggle" onclick="event.stopPropagation()">' +
        '<input type="checkbox"' + (r.showGroups ? ' checked' : '') +
        ' onchange="toggleGroups(' + r.id + ',this.checked)"> Conflict groups</label>';
      if (r.showGroups) {
        var iters = r.rollout.iterations;
        html += '<div class="rollout-card-groups">';
        for (var j = 0; j < iters.length; j++) {
          var graph = (iters[j].diag.summary && iters[j].diag.summary.conflict_graph) || [];
          html += '<div><span class="group-iter">Iter ' + iters[j].iter + ':</span> ';
          if (graph.length === 0) {
            html += '<span style="color:#22c55e">\u2713</span>';
          } else {
            for (var g = 0; g < graph.length; g++) {
              html += '<span class="group-set">{' + graph[g].eids.map(escapeHtml).join(', ') + '}</span>';
            }
          }
          html += '</div>';
        }
        html += '</div>';
      }
    }
    html += '</div>';
  }
  list.innerHTML = html;
}

function toggleGroups(id, show) {
  for (var i = 0; i < window.rollouts.length; i++) {
    if (window.rollouts[i].id === id) {
      window.rollouts[i].showGroups = show;
      break;
    }
  }
  renderSidebar();
}

function selectRollout(id) {
  var entry = null;
  for (var i = 0; i < window.rollouts.length; i++) {
    if (window.rollouts[i].id === id) { entry = window.rollouts[i]; break; }
  }
  if (!entry || entry.loading || !entry.rollout) return;

  stopPlay();
  currentIter = 0;
  animating = false;
  window.activeRolloutId = id;

  document.getElementById('empty-state').style.display = 'none';
  buildViewer(entry.rollout);
  renderSidebar();
}

function removeRollout(id) {
  stopPlay();
  window.rollouts = window.rollouts.filter(function(r) { return r.id !== id; });

  if (window.activeRolloutId === id) {
    window.activeRolloutId = null;
    window.iterDataMeta = null;
    currentIter = 0;
    animating = false;
    document.getElementById('app').style.display = 'none';
    document.getElementById('app').innerHTML = '';

    // Select next available or show empty state
    var nextEntry = null;
    for (var i = 0; i < window.rollouts.length; i++) {
      if (!window.rollouts[i].loading) { nextEntry = window.rollouts[i]; break; }
    }
    if (nextEntry) {
      selectRollout(nextEntry.id);
      return; // selectRollout calls renderSidebar
    } else {
      document.getElementById('empty-state').style.display = 'flex';
    }
  }
  renderSidebar();
}

async function addRollout(file) {
  var id = window.nextRolloutId++;
  var entry = { id: id, name: file.name, rollout: null, loading: true };
  window.rollouts.push(entry);
  renderSidebar();

  try {
    var buffer = await file.arrayBuffer();
    var tarBytes = await decompressGzip(buffer);
    var fileMap = parseTar(tarBytes);
    var rollout = loadRollout(fileMap);
    entry.rollout = rollout;
    entry.loading = false;
    renderSidebar();
    selectRollout(id);
  } catch (err) {
    window.rollouts = window.rollouts.filter(function(r) { return r.id !== id; });
    renderSidebar();
    console.error(err);
    alert('Error loading ' + file.name + ': ' + (err.message || err));
  }
}

function stepBack() {
  stopPlay();
  transitionTo(currentIter - 1);
}

function stepForward() {
  stopPlay();
  transitionTo(currentIter + 1);
}

function jumpTo(idx) {
  stopPlay();
  if (Math.abs(idx - currentIter) <= 1) {
    transitionTo(idx);
  } else {
    switchIter(idx);
  }
}

// ── Keyboard shortcuts ──
document.addEventListener('keydown', function(e) {
  if (!window.iterDataMeta) return;
  if (e.target.tagName === 'INPUT' || e.target.tagName === 'SELECT' || e.target.tagName === 'TEXTAREA') return;
  switch (e.key) {
    case 'ArrowLeft': case 'h': e.preventDefault(); stepBack(); break;
    case 'ArrowRight': case 'l': e.preventDefault(); stepForward(); break;
    case ' ': e.preventDefault(); togglePlay(); break;
    default:
      if (e.key >= '0' && e.key <= '9') {
        var n = +e.key;
        if (n < window.iterDataMeta.length) jumpTo(n);
      }
  }
});

// ── Highlight helpers ──
function highlightChain(eid) {
  // Add dynamic highlight rects to the SVG overlay
  var activeSlide = document.querySelector('.iter-slide[data-iter="' + currentIter + '"]');
  if (activeSlide) {
    var svg = activeSlide.querySelector('.overlay-svg');
    // Read bbox from DOM data
    var meta = window.iterDataMeta[currentIter];
    var domEl = meta.dom.elements.find(function(e) { return e.eid === eid; });
    if (svg && domEl) {
      var ns = 'http://www.w3.org/2000/svg';
      var r = document.createElementNS(ns, 'rect');
      r.setAttribute('x', domEl.bbox.x);
      r.setAttribute('y', domEl.bbox.y);
      r.setAttribute('width', domEl.bbox.w);
      r.setAttribute('height', domEl.bbox.h);
      r.setAttribute('class', 'group-highlight-rect');
      svg.appendChild(r);
    }
  }
  // Bottom bar groups containing this eid
  document.querySelectorAll('.cb-group').forEach(function(g) {
    var groupEids = (g.dataset.groupEids || '').split(',');
    if (groupEids.indexOf(eid) >= 0) g.classList.add('active');
  });
}
function clearChain() {
  document.querySelectorAll('.group-highlight-rect').forEach(function(el) {
    el.remove();
  });
  document.querySelectorAll('.cb-group.active').forEach(function(g) {
    g.classList.remove('active');
  });
}
function highlightDefect(eid) {
  document.querySelectorAll('.defect-group').forEach(function(g) {
    if (g.dataset.defectEid === eid) g.classList.add('active');
  });
}
function clearDefect() {
  document.querySelectorAll('.defect-group.active').forEach(function(g) {
    g.classList.remove('active');
  });
}

// ── Conflict group click handler (toggle) ──
window.activeGroupEl = null;
document.addEventListener('click', function(e) {
  if (!window.iterDataMeta) return;
  var cbg = e.target.closest && e.target.closest('.cb-group');
  if (!cbg) return;
  clearChain();
  if (window.activeGroupEl === cbg) {
    // clicking the same card → deselect
    window.activeGroupEl = null;
    return;
  }
  // select this group
  window.activeGroupEl = cbg;
  var eids = (cbg.dataset.groupEids || '').split(',');
  for (var i = 0; i < eids.length; i++) highlightChain(eids[i]);
});

// ── Unified hover handler ──
var hoverRaf = null;
document.addEventListener('mouseover', function(e) {
  if (!window.iterDataMeta) return;
  if (hoverRaf) cancelAnimationFrame(hoverRaf);
  hoverRaf = requestAnimationFrame(function() {
    var target = e.target;
    // Don't clear chain highlight if a conflict group is actively selected
    if (!window.activeGroupEl) clearChain();
    clearDefect();

    if (target.closest) {
      var dg = target.closest('.defect-group');
      if (dg && dg.dataset.defectEid) highlightDefect(dg.dataset.defectEid);
    }

    var eidTarget = target;
    while (eidTarget && eidTarget !== document.body) {
      if (eidTarget.dataset && eidTarget.dataset.eid) break;
      eidTarget = eidTarget.parentElement;
    }
    if (eidTarget && eidTarget.dataset && eidTarget.dataset.eid) {
      var eid = eidTarget.dataset.eid;
      highlightDefect(eid);
      var meta = window.iterDataMeta[currentIter];
      var elem = meta.elements.find(function(el) { return el.eid === eid; });
      if (elem) {
        var tip = document.getElementById('tooltip');
        var lines = ['<b>' + eid + '</b>', 'type: ' + elem.type, 'priority: ' + elem.priority];
        if (elem.defects.length > 0) {
          lines.push('<hr>');
          elem.defects.forEach(function(d) { lines.push('<span class="tip-defect">' + d.type + '</span> sev=' + d.severity); });
        }
        tip.innerHTML = lines.join('<br>');
        tip.style.display = 'block';
        var rect = eidTarget.getBoundingClientRect();
        tip.style.left = (rect.right + 8) + 'px';
        tip.style.top = rect.top + 'px';
      }
    } else {
      document.getElementById('tooltip').style.display = 'none';
    }
  });
});

document.addEventListener('mouseout', function(e) {
  if (!window.iterDataMeta) return;
  var related = e.relatedTarget;
  if (!related || !related.closest) {
    if (!window.activeGroupEl) clearChain();
    clearDefect();
    document.getElementById('tooltip').style.display = 'none';
    return;
  }
  if (!window.activeGroupEl) clearChain();
  if (!related.closest('.defect-group') && !related.closest('[data-eid]')) clearDefect();
  var inEid = related;
  while (inEid && inEid !== document.body) {
    if (inEid.dataset && inEid.dataset.eid) break;
    inEid = inEid.parentElement;
  }
  if (!inEid || !inEid.dataset || !inEid.dataset.eid) {
    document.getElementById('tooltip').style.display = 'none';
  }
});

// ═══════════════════════════════════════════════════════════════
// Entry point: drop zones + file picker
// ═══════════════════════════════════════════════════════════════

(function() {
  var sidebarDrop = document.getElementById('sidebar-drop');
  var emptyState = document.getElementById('empty-state');
  var fileInput = document.getElementById('file-input');
  var btnAdd = document.getElementById('btn-add');

  function handleFiles(files) {
    for (var i = 0; i < files.length; i++) addRollout(files[i]);
  }

  // + button
  btnAdd.addEventListener('click', function() { fileInput.click(); });

  // Sidebar drop zone
  sidebarDrop.addEventListener('click', function() { fileInput.click(); });
  sidebarDrop.addEventListener('dragover', function(e) {
    e.preventDefault();
    sidebarDrop.classList.add('dragover');
  });
  sidebarDrop.addEventListener('dragleave', function() {
    sidebarDrop.classList.remove('dragover');
  });
  sidebarDrop.addEventListener('drop', function(e) {
    e.preventDefault();
    sidebarDrop.classList.remove('dragover');
    handleFiles(e.dataTransfer.files);
  });

  // Empty state drop zone + click
  emptyState.addEventListener('click', function() { fileInput.click(); });
  emptyState.addEventListener('dragover', function(e) {
    e.preventDefault();
    emptyState.classList.add('dragover');
  });
  emptyState.addEventListener('dragleave', function() {
    emptyState.classList.remove('dragover');
  });
  emptyState.addEventListener('drop', function(e) {
    e.preventDefault();
    emptyState.classList.remove('dragover');
    handleFiles(e.dataTransfer.files);
  });

  // File input
  fileInput.addEventListener('change', function(e) {
    handleFiles(e.target.files);
    fileInput.value = '';
  });
})();
</script>
</body>
</html>
